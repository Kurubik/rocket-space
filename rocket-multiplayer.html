<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Multiplayer Lunar Lander</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      overflow: hidden;
      font-family: 'Courier New', monospace;
      background: #000;
      touch-action: none;
    }
    #gameCanvas {
      display: block;
      cursor: crosshair;
    }
    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #0ff;
      font-size: 14px;
      text-shadow: 0 0 10px #0ff;
      pointer-events: none;
    }
    #playerList {
      position: absolute;
      top: 20px;
      right: 20px;
      color: #0ff;
      font-size: 12px;
      text-shadow: 0 0 10px #0ff;
      pointer-events: none;
    }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      opacity: 0.7;
    }
    .control-btn {
      width: 60px;
      height: 60px;
      background: rgba(0, 255, 255, 0.1);
      border: 2px solid #0ff;
      border-radius: 50%;
      color: #0ff;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: all 0.2s;
    }
    .control-btn:active {
      background: rgba(0, 255, 255, 0.3);
      transform: scale(0.95);
    }
    #missileBtn {
      background: rgba(255, 100, 100, 0.1);
      border-color: #ff6464;
      color: #ff6464;
    }
    #missileBtn:active {
      background: rgba(255, 100, 100, 0.3);
    }
    #missileBtn.cooldown {
      opacity: 0.3;
      cursor: not-allowed;
    }
    #gameControls {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      opacity: 0.7;
    }
    .game-btn {
      padding: 10px 20px;
      background: rgba(0, 255, 255, 0.1);
      border: 2px solid #0ff;
      border-radius: 5px;
      color: #0ff;
      font-size: 12px;
      cursor: pointer;
      user-select: none;
      transition: all 0.2s;
    }
    .game-btn:hover {
      background: rgba(0, 255, 255, 0.3);
    }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      color: #0ff;
      text-align: center;
      text-shadow: 0 0 20px #0ff;
      display: none;
    }
    #connectionStatus {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #0ff;
      font-size: 14px;
      text-shadow: 0 0 10px #0ff;
    }
    #landingIndicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 40px;
      color: #ffd60a;
      text-shadow: 0 0 20px #ffd60a;
      pointer-events: none;
      display: none;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }
    #restartBtn {
      position: absolute;
      top: 60%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 15px 30px;
      background: rgba(0, 255, 255, 0.1);
      border: 2px solid #0ff;
      border-radius: 10px;
      color: #0ff;
      font-size: 18px;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      user-select: none;
      transition: all 0.2s;
      display: none;
      text-shadow: 0 0 10px #0ff;
    }
    #restartBtn:active {
      background: rgba(0, 255, 255, 0.3);
      transform: translate(-50%, -50%) scale(0.95);
    }
    @media (min-width: 768px) {
      #controls {
        display: none;
      }
      #restartBtn {
        display: none !important;
      }
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
  <div>FUEL: <span id="fuel">100</span>%</div>
  <div>VELOCITY: <span id="velocity">0</span> m/s</div>
  <div>ALTITUDE: <span id="altitude">0</span> m</div>
  <div>MISSILES: <span id="missileCount">3</span></div>
  <div style="margin-top: 10px; font-size: 11px; opacity: 0.7;">Press M to launch missile</div>
</div>
<div id="playerList">
  <div><strong>PLAYERS:</strong></div>
  <div id="players"></div>
</div>
<div id="connectionStatus">Connecting...</div>
<div id="controls">
  <div class="control-btn" id="leftBtn">‚óÑ</div>
  <div class="control-btn" id="thrustBtn">‚ñ≤</div>
  <div class="control-btn" id="rightBtn">‚ñ∫</div>
  <div class="control-btn" id="missileBtn">üöÄ</div>
</div>
<div id="gameControls">
  <div class="game-btn" id="newLevelBtn">NEW LEVEL</div>
</div>
<div id="message"></div>
<button id="restartBtn">RESTART</button>
<div id="landingIndicator"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script>
  // Socket connection
  const socket = io();
  let myPlayerId = null;
  let allPlayers = {};
  let gameInitialized = false;

  // Game setup
  const canvas = document.getElementById('gameCanvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000814);

  // Camera setup
  let aspect = window.innerWidth / window.innerHeight;
  const frustumSize = 20;
  const camera = new THREE.OrthographicCamera(
          frustumSize * aspect / -2,
          frustumSize * aspect / 2,
          frustumSize / 2,
          frustumSize / -2,
          0.1,
          1000
  );
  camera.position.z = 10;
  
  // Camera follow settings for mobile
  let isMobile = window.innerWidth < 768;
  let cameraTarget = { x: 0, y: 0 };
  const cameraSmoothing = 0.1;
  
  function updateCameraPosition(deltaTime) {
    if (!isMobile || !myGameState) return;
    
    // Calculate the midpoint between rocket and landing pad
    const rocketX = myGameState.position.x;
    const rocketY = myGameState.position.y;
    
    // Focus on area between rocket and landing pad
    let targetX, targetY;
    
    if (padX !== undefined && padY !== undefined) {
      // Calculate weighted average - bias toward rocket position
      const rocketWeight = 0.7;
      const padWeight = 0.3;
      
      targetX = rocketX * rocketWeight + padX * padWeight;
      targetY = rocketY * rocketWeight + padY * padWeight;
      
      // Ensure landing pad stays visible
      const maxDistX = frustumSize * aspect / 3; // Keep pad within 1/3 of screen width
      const maxDistY = frustumSize / 3; // Keep pad within 1/3 of screen height
      
      // Clamp camera to ensure pad visibility
      if (Math.abs(padX - targetX) > maxDistX) {
        targetX = padX + Math.sign(rocketX - padX) * maxDistX;
      }
      if (Math.abs(padY - targetY) > maxDistY) {
        targetY = padY + Math.sign(rocketY - padY) * maxDistY;
      }
      
      // Show landing pad indicator if it's far away
      updateLandingIndicator(rocketX, rocketY, padX, padY);
    } else {
      // If no landing pad, just follow rocket
      targetX = rocketX;
      targetY = rocketY;
    }
    
    // Smooth camera movement
    cameraTarget.x += (targetX - cameraTarget.x) * cameraSmoothing;
    cameraTarget.y += (targetY - cameraTarget.y) * cameraSmoothing;
    
    // Update camera position
    camera.position.x = cameraTarget.x;
    camera.position.y = cameraTarget.y;
    
    // Also move stars for parallax effect
    if (stars) {
      stars.position.x = cameraTarget.x * 0.1;
      stars.position.y = cameraTarget.y * 0.1;
    }
  }
  
  function updateLandingIndicator(rocketX, rocketY, padX, padY) {
    const indicator = document.getElementById('landingIndicator');
    if (!indicator || !isMobile) return;
    
    // Calculate distance to landing pad
    const dx = padX - rocketX;
    const dy = padY - rocketY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // Show indicator if pad is far
    if (distance > 8) {
      // Calculate angle to pad
      const angle = Math.atan2(dy, dx);
      
      // Convert to arrow emoji based on direction
      let arrow = '';
      const angleDeg = (angle * 180 / Math.PI + 360) % 360;
      
      if (angleDeg >= 337.5 || angleDeg < 22.5) arrow = '‚Üí';
      else if (angleDeg >= 22.5 && angleDeg < 67.5) arrow = '‚Üò';
      else if (angleDeg >= 67.5 && angleDeg < 112.5) arrow = '‚Üì';
      else if (angleDeg >= 112.5 && angleDeg < 157.5) arrow = '‚Üô';
      else if (angleDeg >= 157.5 && angleDeg < 202.5) arrow = '‚Üê';
      else if (angleDeg >= 202.5 && angleDeg < 247.5) arrow = '‚Üñ';
      else if (angleDeg >= 247.5 && angleDeg < 292.5) arrow = '‚Üë';
      else if (angleDeg >= 292.5 && angleDeg < 337.5) arrow = '‚Üó';
      
      indicator.textContent = arrow;
      indicator.style.display = 'block';
      
      // Position indicator at edge of screen
      const edgeDist = 100; // pixels from edge
      const indicatorX = 50 + Math.cos(angle) * 30;
      const indicatorY = 50 - Math.sin(angle) * 30;
      
      indicator.style.left = indicatorX + '%';
      indicator.style.top = indicatorY + '%';
    } else {
      indicator.style.display = 'none';
    }
  }

  // Add stars background
  const starsGeometry = new THREE.BufferGeometry();
  const starCount = 200;
  const starPositions = [];
  for (let i = 0; i < starCount; i++) {
    starPositions.push(
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 30,
            -5
    );
  }
  starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
  const stars = new THREE.Points(starsGeometry, starsMaterial);
  scene.add(stars);

  // Game objects
  let rockets = {};
  let terrain, landingPad, leftMarker, rightMarker;
  let terrainPoints = [];
  let padX, padY, padWidth = 2;

  // My player state
  let myGameState = {
    position: { x: 0, y: 5 },
    velocity: { x: 0, y: 0 },
    rotation: 0,
    fuel: 100,
    gameOver: false,
    won: false,
    missiles: 3,
    missileCooldown: 0
  };

  // Controls
  const keys = {};
  let touchControls = { left: false, right: false, thrust: false };
  
  // Missiles array
  const missiles = [];

  // Particle system for thrust
  const particles = [];
  class Particle {
    constructor(x, y, vx, vy, color = 0xff6b00) {
      this.geometry = new THREE.CircleGeometry(0.05, 6);
      this.material = new THREE.MeshBasicMaterial({
        color: new THREE.Color(color),
        transparent: true
      });
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.mesh.position.set(x, y, 0);
      this.velocity = { x: vx, y: vy };
      this.life = 1;
      scene.add(this.mesh);
      particles.push(this);
    }

    update(deltaTime) {
      this.mesh.position.x += this.velocity.x * deltaTime;
      this.mesh.position.y += this.velocity.y * deltaTime;
      this.life -= deltaTime * 3;
      this.material.opacity = this.life;

      if (this.life <= 0) {
        scene.remove(this.mesh);
        const index = particles.indexOf(this);
        if (index > -1) particles.splice(index, 1);
      }
    }
  }

  // Missile class
  class Missile {
    constructor(x, y, targetPlayerId, ownerId) {
      this.position = { x, y };
      this.velocity = { x: 0, y: 0 };
      this.targetPlayerId = targetPlayerId;
      this.ownerId = ownerId;
      this.speed = 10;
      this.life = 5; // 5 seconds lifetime
      this.turnRate = 5;
      
      // Create missile mesh
      const missileGeometry = new THREE.ConeGeometry(0.15, 0.6, 6);
      const missileMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 0.5
      });
      this.mesh = new THREE.Mesh(missileGeometry, missileMaterial);
      this.mesh.position.set(x, y, 0.5);
      scene.add(this.mesh);
      
      // Add trail effect
      this.trailParticles = [];
      
      missiles.push(this);
    }
    
    update(deltaTime) {
      this.life -= deltaTime;
      
      // Remove if expired
      if (this.life <= 0) {
        this.destroy();
        return;
      }
      
      // Find target
      const target = allPlayers[this.targetPlayerId];
      if (!target || target.gameOver) {
        // Find new target if current one is gone
        this.findNewTarget();
      }
      
      if (this.targetPlayerId && allPlayers[this.targetPlayerId]) {
        const target = allPlayers[this.targetPlayerId];
        
        // Calculate direction to target
        const dx = target.position.x - this.position.x;
        const dy = target.position.y - this.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Check for hit
        if (distance < 0.5) {
          // Hit target!
          this.explode();
          
          // If it's my missile hitting someone
          if (this.ownerId === myPlayerId && this.targetPlayerId !== myPlayerId) {
            socket.emit('missileHit', { 
              targetId: this.targetPlayerId,
              attackerId: this.ownerId 
            });
          }
          
          // If I'm the target
          if (this.targetPlayerId === myPlayerId && !myGameState.gameOver) {
            myGameState.gameOver = true;
            const message = window.innerWidth < 768 ? "MISSILE HIT!" : "MISSILE HIT!<br>Press SPACE to restart";
            showMessage(message);
            createExplosion();
            socket.emit('playerUpdate', myGameState);
          }
          
          return;
        }
        
        // Update velocity to track target
        const angle = Math.atan2(dy, dx);
        const currentAngle = Math.atan2(this.velocity.y, this.velocity.x);
        
        // Smooth turning
        let angleDiff = angle - currentAngle;
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        
        const newAngle = currentAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), this.turnRate * deltaTime);
        
        this.velocity.x = Math.cos(newAngle) * this.speed;
        this.velocity.y = Math.sin(newAngle) * this.speed;
      } else {
        // No target, fly straight
        if (this.velocity.x === 0 && this.velocity.y === 0) {
          this.velocity.y = this.speed;
        }
      }
      
      // Update position
      this.position.x += this.velocity.x * deltaTime;
      this.position.y += this.velocity.y * deltaTime;
      
      // Update mesh
      this.mesh.position.set(this.position.x, this.position.y, 0.5);
      const angle = Math.atan2(this.velocity.y, this.velocity.x);
      this.mesh.rotation.z = angle - Math.PI/2;
      
      // Create trail
      if (Math.random() < 0.8) {
        new Particle(
          this.position.x - Math.cos(angle) * 0.3,
          this.position.y - Math.sin(angle) * 0.3,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2 - 1,
          0xffaa00
        );
      }
      
      // Check terrain collision
      for (let i = 0; i < terrainPoints.length - 1; i++) {
        const p1 = terrainPoints[i];
        const p2 = terrainPoints[i + 1];
        
        if (this.position.x >= p1.x && this.position.x <= p2.x) {
          const t = (this.position.x - p1.x) / (p2.x - p1.x);
          const terrainY = p1.y + t * (p2.y - p1.y);
          
          if (this.position.y - 0.3 <= terrainY) {
            this.explode();
            return;
          }
        }
      }
      
      // Remove if out of bounds
      if (Math.abs(this.position.x) > 25 || this.position.y > 20 || this.position.y < -15) {
        this.destroy();
      }
    }
    
    findNewTarget() {
      let closestDistance = Infinity;
      let newTarget = null;
      
      Object.keys(allPlayers).forEach(playerId => {
        if (playerId !== this.ownerId && !allPlayers[playerId].gameOver) {
          const dx = this.position.x - allPlayers[playerId].position.x;
          const dy = this.position.y - allPlayers[playerId].position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < closestDistance) {
            closestDistance = distance;
            newTarget = playerId;
          }
        }
      });
      
      this.targetPlayerId = newTarget;
    }
    
    explode() {
      // Create explosion effect
      for (let i = 0; i < 20; i++) {
        const angle = (Math.PI * 2 * i) / 20;
        const speed = Math.random() * 8 + 4;
        new Particle(
          this.position.x,
          this.position.y,
          Math.cos(angle) * speed,
          Math.sin(angle) * speed,
          0xff0000
        );
      }
      this.destroy();
    }
    
    destroy() {
      scene.remove(this.mesh);
      const index = missiles.indexOf(this);
      if (index > -1) missiles.splice(index, 1);
    }
  }

  function createRocket(playerId, color = 0xff6b6b) {
    const rocket = new THREE.Group();

    // Rocket body
    const bodyGeometry = new THREE.BufferGeometry();
    const bodyVertices = new Float32Array([
      0, 0.8, 0,      // top
      -0.3, -0.5, 0,  // bottom left
      0.3, -0.5, 0,   // bottom right
    ]);
    bodyGeometry.setAttribute('position', new THREE.BufferAttribute(bodyVertices, 3));
    const bodyMaterial = new THREE.MeshBasicMaterial({ color: color });
    const rocketBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
    rocket.add(rocketBody);

    // Rocket fins
    const finGeometry = new THREE.PlaneGeometry(0.2, 0.3);
    const finMaterial = new THREE.MeshBasicMaterial({ color: 0x4ecdc4 });
    const leftFin = new THREE.Mesh(finGeometry, finMaterial);
    leftFin.position.set(-0.25, -0.3, 0);
    rocket.add(leftFin);
    const rightFin = new THREE.Mesh(finGeometry, finMaterial);
    rightFin.position.set(0.25, -0.3, 0);
    rocket.add(rightFin);

    scene.add(rocket);
    rockets[playerId] = rocket;
    return rocket;
  }

  function createTerrain(terrainData) {
    // Remove existing terrain
    if (terrain) scene.remove(terrain);
    if (landingPad) scene.remove(landingPad);
    if (leftMarker) scene.remove(leftMarker);
    if (rightMarker) scene.remove(rightMarker);

    terrainPoints = terrainData.points;
    padX = terrainData.landingPad.x;
    padY = terrainData.landingPad.y;
    padWidth = terrainData.landingPad.width;

    // Create terrain mesh
    const terrainShape = new THREE.Shape();
    terrainShape.moveTo(terrainPoints[0].x, terrainPoints[0].y);
    for (let i = 1; i < terrainPoints.length; i++) {
      terrainShape.lineTo(terrainPoints[i].x, terrainPoints[i].y);
    }
    terrainShape.lineTo(20, -15);
    terrainShape.lineTo(-20, -15);
    terrainShape.closePath();

    const terrainGeometry = new THREE.ShapeGeometry(terrainShape);
    const terrainMaterial = new THREE.MeshBasicMaterial({ color: 0x95a99c });
    terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
    scene.add(terrain);

    // Create landing pad
    const padGeometry = new THREE.PlaneGeometry(padWidth, 0.2);
    const padMaterial = new THREE.MeshBasicMaterial({ color: 0xffd60a });
    landingPad = new THREE.Mesh(padGeometry, padMaterial);
    landingPad.position.set(padX, padY, 0.1);
    scene.add(landingPad);

    // Add landing pad markers
    const markerGeometry = new THREE.PlaneGeometry(0.1, 0.5);
    const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    leftMarker = new THREE.Mesh(markerGeometry, markerMaterial);
    leftMarker.position.set(padX - padWidth/2, padY + 0.3, 0.1);
    scene.add(leftMarker);
    rightMarker = new THREE.Mesh(markerGeometry, markerMaterial);
    rightMarker.position.set(padX + padWidth/2, padY + 0.3, 0.1);
    scene.add(rightMarker);
  }

  function updatePlayerList() {
    const playersDiv = document.getElementById('players');
    playersDiv.innerHTML = '';
    
    Object.values(allPlayers).forEach(player => {
      const playerDiv = document.createElement('div');
      playerDiv.innerHTML = `
        <span style="color: ${player.color}">‚óè</span> 
        Player ${player.id.substr(0, 6)}
        ${player.gameOver ? (player.won ? ' üèÜ' : ' üí•') : ''}
      `;
      playersDiv.appendChild(playerDiv);
    });
  }

  function checkCollision() {
    const rocketBottom = myGameState.position.y - 0.5;

    // Check collision with other rockets
    Object.keys(allPlayers).forEach(playerId => {
      if (playerId !== myPlayerId) { // Don't check collision with self
        const otherPlayer = allPlayers[playerId];
        if (!otherPlayer.gameOver && !myGameState.gameOver) { // Only check if both players are still alive
          // Calculate distance between rockets (simple circle collision detection)
          const dx = myGameState.position.x - otherPlayer.position.x;
          const dy = myGameState.position.y - otherPlayer.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // If rockets are too close (collision radius of about 0.8 units)
          if (distance < 0.8) {
            myGameState.gameOver = true;
            const message = window.innerWidth < 768 ? "COLLISION!" : "COLLISION!<br>Press SPACE to restart";
            showMessage(message);
            createExplosion();
            
            // Send update to server so other players know we crashed
            socket.emit('playerUpdate', myGameState);
            return true;
          }
        }
      }
    });

    // Check landing pad
    if (Math.abs(myGameState.position.x - padX) < padWidth/2 &&
            rocketBottom <= padY + 0.1 && rocketBottom >= padY - 0.1) {

      const speed = Math.sqrt(myGameState.velocity.x ** 2 + myGameState.velocity.y ** 2);
      if (speed < 2 && Math.abs(myGameState.rotation) < 0.2) {
        myGameState.won = true;
        myGameState.gameOver = true;
        const message = window.innerWidth < 768 ? "PERFECT LANDING!" : "PERFECT LANDING!<br>Press SPACE to restart";
        showMessage(message);
      } else {
        myGameState.gameOver = true;
        const message = window.innerWidth < 768 ? "TOO FAST!" : "TOO FAST!<br>Press SPACE to restart";
        showMessage(message);
        createExplosion();
      }
      return true;
    }

    // Check terrain collision
    for (let i = 0; i < terrainPoints.length - 1; i++) {
      const p1 = terrainPoints[i];
      const p2 = terrainPoints[i + 1];

      if (myGameState.position.x >= p1.x && myGameState.position.x <= p2.x) {
        const t = (myGameState.position.x - p1.x) / (p2.x - p1.x);
        const terrainY = p1.y + t * (p2.y - p1.y);

        if (rocketBottom <= terrainY) {
          myGameState.gameOver = true;
          const message = window.innerWidth < 768 ? "CRASH!" : "CRASH!<br>Press SPACE to restart";
          showMessage(message);
          createExplosion();
          return true;
        }
      }
    }

    return false;
  }

  function createExplosion() {
    for (let i = 0; i < 30; i++) {
      const angle = (Math.PI * 2 * i) / 30;
      const speed = Math.random() * 5 + 2;
      new Particle(
              myGameState.position.x,
              myGameState.position.y,
              Math.cos(angle) * speed,
              Math.sin(angle) * speed,
              0xff0000
      );
    }
  }

  function showMessage(text) {
    const messageEl = document.getElementById('message');
    messageEl.innerHTML = text;
    messageEl.style.display = 'block';
    
    // Show restart button on mobile devices
    const restartBtn = document.getElementById('restartBtn');
    if (window.innerWidth < 768) {
      restartBtn.style.display = 'block';
    }
  }

  function hideMessage() {
    document.getElementById('message').style.display = 'none';
    document.getElementById('restartBtn').style.display = 'none';
  }

  function resetMyPlayer() {
    myGameState = {
      position: { x: (Math.random() - 0.5) * 10, y: 5 },
      velocity: { x: (Math.random() - 0.5) * 2, y: 0 },
      rotation: 0,
      fuel: 100,
      gameOver: false,
      won: false,
      missiles: 3,
      missileCooldown: 0
    };
    hideMessage();
    particles.forEach(p => scene.remove(p.mesh));
    particles.length = 0;
    
    // Clear my missiles
    missiles.forEach(m => {
      if (m.ownerId === myPlayerId) {
        m.destroy();
      }
    });
    
    socket.emit('restartGame');
  }
  
  function launchMissile() {
    if (myGameState.gameOver || myGameState.missiles <= 0 || myGameState.missileCooldown > 0) {
      return;
    }
    
    // Find closest enemy
    let closestDistance = Infinity;
    let targetId = null;
    
    Object.keys(allPlayers).forEach(playerId => {
      if (playerId !== myPlayerId && !allPlayers[playerId].gameOver) {
        const dx = myGameState.position.x - allPlayers[playerId].position.x;
        const dy = myGameState.position.y - allPlayers[playerId].position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < closestDistance) {
          closestDistance = distance;
          targetId = playerId;
        }
      }
    });
    
    if (targetId) {
      // Launch missile
      new Missile(
        myGameState.position.x,
        myGameState.position.y - 0.5,
        targetId,
        myPlayerId
      );
      
      myGameState.missiles--;
      myGameState.missileCooldown = 3; // 3 second cooldown
      
      // Notify server
      socket.emit('missileLaunched', {
        from: myPlayerId,
        target: targetId,
        position: { x: myGameState.position.x, y: myGameState.position.y - 0.5 }
      });
      
      // Update button visual
      const missileBtn = document.getElementById('missileBtn');
      missileBtn.classList.add('cooldown');
      missileBtn.textContent = myGameState.missiles;
    }
  }

  function update(deltaTime) {
    if (myGameState.gameOver) {
      if (keys[' '] || keys['Enter']) {
        resetMyPlayer();
      }
      return;
    }
    
    // Update missile cooldown
    if (myGameState.missileCooldown > 0) {
      myGameState.missileCooldown -= deltaTime;
      if (myGameState.missileCooldown <= 0) {
        myGameState.missileCooldown = 0;
        const missileBtn = document.getElementById('missileBtn');
        missileBtn.classList.remove('cooldown');
        missileBtn.textContent = myGameState.missiles > 0 ? 'üöÄ' : '0';
      }
    }
    
    // Launch missile on key press
    if (keys['m'] || keys['M']) {
      launchMissile();
      keys['m'] = false;
      keys['M'] = false;
    }

    // Handle input for my player only
    if ((keys['ArrowLeft'] || keys['a'] || touchControls.left) && myGameState.fuel > 0) {
      myGameState.rotation += deltaTime * 3;  // A key rotates counter-clockwise
      myGameState.fuel -= deltaTime * 5;
    }
    if ((keys['ArrowRight'] || keys['d'] || touchControls.right) && myGameState.fuel > 0) {
      myGameState.rotation -= deltaTime * 3;  // D key rotates clockwise
      myGameState.fuel -= deltaTime * 5;
    }
    if ((keys['ArrowUp'] || keys['w'] || keys[' '] || touchControls.thrust) && myGameState.fuel > 0) {
      const thrust = 8;
      myGameState.velocity.x -= Math.sin(myGameState.rotation) * thrust * deltaTime;
      myGameState.velocity.y += Math.cos(myGameState.rotation) * thrust * deltaTime;
      myGameState.fuel -= deltaTime * 20;

      // Create thrust particles
      if (Math.random() < 0.8) {
        const spreadAngle = (Math.random() - 0.5) * 0.5;
        const player = allPlayers[myPlayerId];
        const color = player ? parseInt(player.color.replace('#', '0x')) : 0xff6b00;
        new Particle(
                myGameState.position.x + Math.sin(myGameState.rotation) * 0.5,
                myGameState.position.y - Math.cos(myGameState.rotation) * 0.5,
                Math.sin(myGameState.rotation + spreadAngle) * 3,
                -Math.cos(myGameState.rotation + spreadAngle) * 3,
                color
        );
      }
    }

    // Apply gravity
    myGameState.velocity.y -= 2 * deltaTime;

    // Update position
    myGameState.position.x += myGameState.velocity.x * deltaTime;
    myGameState.position.y += myGameState.velocity.y * deltaTime;

    // Screen wrapping
    const screenBounds = frustumSize * aspect / 2;
    if (myGameState.position.x > screenBounds) {
      myGameState.position.x = -screenBounds;
    } else if (myGameState.position.x < -screenBounds) {
      myGameState.position.x = screenBounds;
    }

    // Clamp fuel
    myGameState.fuel = Math.max(0, myGameState.fuel);

    // Check if rocket is too high or too low
    if (myGameState.position.y > 15) {
      myGameState.position.y = 15;
      myGameState.velocity.y = Math.min(myGameState.velocity.y, 0);
    } else if (myGameState.position.y < -10) {
      myGameState.gameOver = true;
      const message = window.innerWidth < 768 ? "CRASHED!" : "CRASHED!<br>Press SPACE to restart";
      showMessage(message);
    }

    // Check collision
    checkCollision();

    // Update UI
    document.getElementById('fuel').textContent = Math.round(myGameState.fuel);
    const speed = Math.sqrt(myGameState.velocity.x ** 2 + myGameState.velocity.y ** 2);
    document.getElementById('velocity').textContent = speed.toFixed(1);
    document.getElementById('altitude').textContent = Math.max(0, myGameState.position.y - padY).toFixed(1);
    document.getElementById('missileCount').textContent = myGameState.missiles;

    // Update particles
    particles.forEach(p => p.update(deltaTime));
    
    // Update missiles
    missiles.forEach(m => m.update(deltaTime));

    // Update all rocket positions and check for proximity warnings
    Object.keys(allPlayers).forEach(playerId => {
      if (rockets[playerId]) {
        // Update rocket position
        if (playerId === myPlayerId) {
          // Use my local game state for smoother movement
          rockets[playerId].position.set(myGameState.position.x, myGameState.position.y, 0);
          rockets[playerId].rotation.z = myGameState.rotation;
        } else if (allPlayers[playerId]) {
          // Use server state for other players
          const player = allPlayers[playerId];
          rockets[playerId].position.set(player.position.x, player.position.y, 0);
          rockets[playerId].rotation.z = player.rotation;
        }
        
        // Add proximity warning effect for my rocket only
        if (playerId === myPlayerId && !myGameState.gameOver) {
          let tooClose = false;
          
          // Check distance to other players for warning effect
          Object.keys(allPlayers).forEach(otherPlayerId => {
            if (otherPlayerId !== myPlayerId && !allPlayers[otherPlayerId].gameOver) {
              const other = allPlayers[otherPlayerId];
              const dx = myGameState.position.x - other.position.x;
              const dy = myGameState.position.y - other.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              // Warning zone: 1.5 units (collision at 0.8)
              if (distance < 1.5) {
                tooClose = true;
              }
            }
          });
          
          // Flash the rocket body when too close
          if (tooClose && rockets[playerId].children[0]) {
            const flashIntensity = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
            rockets[playerId].children[0].material.color.setRGB(
              1, 
              flashIntensity, 
              flashIntensity
            );
          } else if (rockets[playerId].children[0]) {
            // Reset to normal color
            const color = new THREE.Color(allPlayers[playerId].color);
            rockets[playerId].children[0].material.color = color;
          }
        }
      }
    });

    // Send my state to server
    socket.emit('playerUpdate', myGameState);
    
    // Update camera position for mobile
    updateCameraPosition(deltaTime);
  }

  // Socket events
  socket.on('connect', () => {
    document.getElementById('connectionStatus').textContent = 'Connected';
    document.getElementById('connectionStatus').style.color = '#0f0';
  });

  socket.on('disconnect', () => {
    document.getElementById('connectionStatus').textContent = 'Disconnected';
    document.getElementById('connectionStatus').style.color = '#f00';
  });

  socket.on('gameState', (data) => {
    myPlayerId = data.yourId;
    allPlayers = data.players;
    
    // Create terrain
    createTerrain(data.terrain);
    
    // Create rockets for all players
    Object.keys(data.players).forEach(playerId => {
      const player = data.players[playerId];
      if (!rockets[playerId]) {
        createRocket(playerId, player.color);
      }
    });
    
    // Set my game state
    if (allPlayers[myPlayerId]) {
      myGameState = { ...allPlayers[myPlayerId] };
    }
    
    updatePlayerList();
    gameInitialized = true;
  });

  socket.on('playerJoined', (player) => {
    allPlayers[player.id] = player;
    if (!rockets[player.id]) {
      createRocket(player.id, player.color);
    }
    updatePlayerList();
  });

  socket.on('playerLeft', (playerId) => {
    if (rockets[playerId]) {
      scene.remove(rockets[playerId]);
      delete rockets[playerId];
    }
    delete allPlayers[playerId];
    updatePlayerList();
  });

  socket.on('playerUpdate', (data) => {
    if (allPlayers[data.playerId]) {
      allPlayers[data.playerId] = { ...allPlayers[data.playerId], ...data };
    }
    updatePlayerList();
  });

  socket.on('playerRestart', (playerId) => {
    if (allPlayers[playerId]) {
      allPlayers[playerId].gameOver = false;
      allPlayers[playerId].won = false;
    }
    updatePlayerList();
  });

  socket.on('newLevel', (data) => {
    createTerrain(data.terrain);
    allPlayers = data.players;
    
    // Ensure all rockets exist for all players
    Object.keys(allPlayers).forEach(playerId => {
      const player = allPlayers[playerId];
      if (!rockets[playerId]) {
        createRocket(playerId, player.color);
      }
    });
    
    if (allPlayers[myPlayerId]) {
      myGameState = { ...allPlayers[myPlayerId] };
    }
    
    hideMessage();
    particles.forEach(p => scene.remove(p.mesh));
    particles.length = 0;
    
    // Clear all missiles
    missiles.forEach(m => m.destroy());
    
    updatePlayerList();
  });
  
  // Missile events
  socket.on('missileLaunched', (data) => {
    if (data.from !== myPlayerId) {
      // Create missile from other player
      new Missile(data.position.x, data.position.y, data.target, data.from);
    }
  });
  
  socket.on('missileHit', (data) => {
    if (data.targetId === myPlayerId && !myGameState.gameOver) {
      myGameState.gameOver = true;
      const message = window.innerWidth < 768 ? "MISSILE HIT!" : "MISSILE HIT!<br>Press SPACE to restart";
      showMessage(message);
      createExplosion();
    }
  });

  // Event listeners
  window.addEventListener('keydown', (e) => {
    keys[e.key] = true;
    if (e.key === ' ') e.preventDefault();
  });

  window.addEventListener('keyup', (e) => {
    keys[e.key] = false;
  });

  // Mobile controls
  document.getElementById('leftBtn').addEventListener('touchstart', () => touchControls.left = true);
  document.getElementById('leftBtn').addEventListener('touchend', () => touchControls.left = false);
  document.getElementById('rightBtn').addEventListener('touchstart', () => touchControls.right = true);
  document.getElementById('rightBtn').addEventListener('touchend', () => touchControls.right = false);
  document.getElementById('thrustBtn').addEventListener('touchstart', () => touchControls.thrust = true);
  document.getElementById('thrustBtn').addEventListener('touchend', () => touchControls.thrust = false);

  // Mouse controls for desktop
  document.getElementById('leftBtn').addEventListener('mousedown', () => touchControls.left = true);
  document.getElementById('leftBtn').addEventListener('mouseup', () => touchControls.left = false);
  document.getElementById('rightBtn').addEventListener('mousedown', () => touchControls.right = true);
  document.getElementById('rightBtn').addEventListener('mouseup', () => touchControls.right = false);
  document.getElementById('thrustBtn').addEventListener('mousedown', () => touchControls.thrust = true);
  document.getElementById('thrustBtn').addEventListener('mouseup', () => touchControls.thrust = false);
  
  // Restart button for mobile
  document.getElementById('restartBtn').addEventListener('click', resetMyPlayer);
  document.getElementById('restartBtn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    resetMyPlayer();
  });
  
  // Missile button
  document.getElementById('missileBtn').addEventListener('click', launchMissile);
  document.getElementById('missileBtn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    launchMissile();
  });

  // New level button
  document.getElementById('newLevelBtn').addEventListener('click', () => {
    socket.emit('newLevel');
  });

  // Animation loop
  let lastTime = 0;
  function animate(currentTime) {
    requestAnimationFrame(animate);

    if (!gameInitialized) return;

    const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
    lastTime = currentTime;

    update(deltaTime);

    renderer.render(scene, camera);
  }

  // Handle resize
  window.addEventListener('resize', () => {
    aspect = window.innerWidth / window.innerHeight;
    isMobile = window.innerWidth < 768;
    camera.left = frustumSize * aspect / -2;
    camera.right = frustumSize * aspect / 2;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Start game
  animate(0);
</script>
</body>
</html>